\chapter{Software}
    \section{Detector Interface}
        The central component of the \textit{XRS-A} is the \textit{microDXP} manufactured by \textsc{XIA LLC}.
        \textsc{XIA} provides USB drivers and a GUI tool \textit{ProSpect} for Windows but no pre-compiled binaries for Linux systems.
        The sources for the software API \textit{Handel} however are provided on their public repository on \textsc{GitHub}~\cite{Software.HandelRelease.2023} and are forked by the author of this work~\cite{Software.XraythesisHandel.2023}.
        As stated in Handels API documentation \textquote{Handel is a framework of several libraries that interact to create the interface Handel provides}~\cite{Manual.HandelAPIManual.Xiang}.
        As such, all routines not part of that top-level framework are considered lower layers of Handels API and will not be subject of this work.
        The used detector incorporates a \textit{microDXP}-platform.
        Thus, all non-\textit{microDXP} routines will not be discussed here as well.\par\medskip

        \subsection{Building the Libraries}\label{sec:building libraries}
            The SBC runs the latest x64 version of \textit{Raspberry Pi OS Lite}\footnote{Installed using the \textit{Raspberry Pi Imager} tool.
            Direct download available under~\cite{Software.RaspberryPiOSLite.2023}}.
            A detailed description and troubleshooting suggestions can be found on the author's repository~\cite{Software.XraythesisHandel.2023}.\par\medskip

            \textit{Handel} is meant to be build using \textit{SCons}~--~\textquote{a computer software build tool} which in turn is written in python.
            Thus, it is dependent on a working python environment.
            While Raspberry Pi OS has a Python interpreter pre-installed, its version does not match SCons requirements.
            Not only to ensure consistent and reproducible development environment but also to keep the Python environment isolated from the system a forked version of miniconda\footnote{\textquote{a small bootstrap version of Anaconda that includes only conda, Python, the packages they both depend on, and a small number of other useful packages}}~--~\textit{miniforge}~--~is used.
            As of the time of writing, Miniconda does not provide a build working on arm64 architecture.

            With a working conda install set up a virtual environment is created installing the specific Python version~\num{3.9} and activated.
            Next, the required Python packages are installed and~--~if not already bundles with the \textit{Raspberry Pi OS} install~--~the \texttt{libusb-dev} libraries.
            \begin{lstlisting}[style=mybash, caption={[Creating conda environment and installing dependencies]Creating conda environment and installing dependencies.}, label={lst:creating conda env}]
    # Create conda environment
    conda create -n xmagix python=3.9 pip ipykernel
    conda activate xmagix

    # Install required python packages
    pip install -r requirements.txt

    # Install other dependencies
    sudo apt install libusb-dev
            \end{lstlisting}

            The main entry point is the shell script \texttt{./build.sh}\footnote{See \cite{Software.XraythesisHandel.2023} for a list of other/more build options.}.
            To start the build process it needs to be made executable and executed using the commands shown in~\cref{lst:build.sh}.
            A build log will be created in \texttt{./build.log} and the default build location is \texttt{./myapp/lib/}.
            \begin{lstlisting}[style=mybash, caption={[Executing build script]Executing build script.}, label={lst:build.sh}]
    # Make script executable
    chmod +x ./build.sh

    # Build
    ./build.sh
            \end{lstlisting}
        \subsection{Permissions and Preparing USB}
            After the detector is plugged into one of the USB ports and is powered up, issue
            \begin{lstlisting}[style=mybash, numbers=none, label={lst:lsusb}]
    lsusb | grep "ID 10e9"
            \end{lstlisting}
            to check that \textit{libusb} sees the XIA device.
            \texttt{udev} rules need to be put in place to grant user-level access to the USB device.
            First, check if the logged in user is in the \texttt{plugdev} group using the command
            \begin{lstlisting}[style=mybash, numbers=none, label={lst:udev}]
    groups | grep "plugdev"
            \end{lstlisting}
            Issuing
            \begin{lstlisting}[style=mybash, numbers=none, label={lst:udev}]
    sudo echo 'ACTION=="add", SUBSYSTEM=="usb", ATTR{idVendor}=="10e9", ATTRS{idProduct}=="0b01", MODE="0660", GROUP="plugdev"' | sudo tee /etc/udev/rules.d/99-xia.rules
    sudo /etc/init.d/udev restart
            \end{lstlisting}
            creates the file \texttt{/etc/udev/rules.d/99-xia.rules} containing a custom \texttt{udev} rule and restarts the \texttt{udev} daemon\footnote{See~\cite{Software.XraythesisHandel.2023} for a non-comprehensive troubleshooting guide.}~\cite{Software.HandelRelease.2023,Software.XraythesisHandel.2023}.

    \section{Python Wrapper}
        The main language chosen to interface with the created shared object (\texttt{*.so}) libraries is Python using the same environment created in~\cref{lst:creating conda env}.
        The class \texttt{XMagix} defined in \texttt{./myapp/xmagix.py} exposes most of the relevant functions of the Handel API and is mostly written in plain Python.
        The only external packages loaded are \textit{Numpy} and \textit{Rich}.
        The former to enable fast matrix manipulation and the latter to auto-timestamp and colorize logging prints to console.\par\medskip

        Furthermore, to actually develop wrapping code Pythons standard library \textit{ctypes} was used to access \textit{Handels} C-functions.
        Following, only the most relevant methods of \texttt{XMagix} are shown.
        See \cref{lst:xmagix class} for a full overview.\par\medskip

        All of Handels top-level functions are named camel case and begin with ``xia''~--~they are called hereafter xia-functions.
        The Python-wrapped methods adopt their naming scheme but omit ``xia'' e.g. Handels API function \texttt{xiaInit(inifile)} is exposed as \texttt{<class object name>.init(inifile)}.
        Any call to an xia-function takes either a value of type \texttt{c\_int()} to specify the detector channel (in this case always \texttt{0} as there is only one detector present), an ascii-encoded byte-stream representing an instruction and a reference to a predefined \textit{ctype}-variable either holding a value to set to or to receive a value retrieved by the particular xia-function.
        \texttt{XMagix}' method \texttt{stringToBytes()} takes a \texttt{str}-object as an input and returns a byte-stream.
        Practical examples are shown in \crefrange{sec:init}{sec:pullMcaData}.

        \begin{lstlisting}[style=mypython, firstnumber=13, caption={[XMagix class constructor]XMagix class constructor.}, label={lst:xmagix constructor}]
    class XMagix:
        """Wrapper class to expose handel API functions."""

        def __init__(self, libpath):
            self.systemUp = False
            self._lib = None
            self.libpath = libpath
            self.cdetChan = c_int(0)
            try:
                self._lib = cdll.LoadLibrary(self.libpath)
            except Exception:
                # Return traceback on error
                console.log("[red]Aw naw :disappointed: wrong file/path?[red]")
            else:
                console.log("[green]Library loaded successfully :smile:[/green]")
        \end{lstlisting}
        The constructor of \texttt{XMagix}, as shown in~\cref{lst:xmagix constructor}, does, besides pre-setting some internal state variables, load the shared object library from the path passed to it during object creation.
        
        \subsection{init()}\label{sec:init}
            With the detector came a pre-defined \texttt{*.ini}-file holding values and variables pre-defined by the manufacturer and specific to that particular device.
            Handel expects it to be loaded prior to starting up the system.
            One does not need to modify any of its values except the line defining the \texttt{device\_number}.
            \texttt{device\_number} tells Handel which USB device to communicate with.\par\medskip
            
            \begin{lstlisting}[style=mypython, firstnumber=67, caption={[XMagix method init()]XMagix method init().}, label={lst:xmagix init}]
    def init(self, inifile):
        """Initializes the Handel library and loads in an .ini file. The functionality of this
        routine can be emulated by calling xiaInitHandel() followed by xiaLoadSys-
        tem()("handel_ini", iniFile). Either this routine or xiaInitHandel must be
        called prior to using the other Handel routines.
        """

        self.inifile = inifile
        self.status = self._lib.xiaInit(self.stringToBytes(inifile))
        self.CHECK_ERROR("Loading system...")
            \end{lstlisting}
        
        \subsection{startSystem()}\label{sec:startSystem}
            After initializing the system using the method described in \cref{sec:init}, one can start up the system using \texttt{<class object name>.startSystem()}.
            No error codes printed to the console indicates a successful start-up\footnote{\texttt{4001, DXP\_MDOPEN} might indicate a wrong \texttt{device\_number}. If there is more than one USB device plugged into the SBC one might try setting \texttt{device\_number} to an integer value > \texttt{0}.}.\par\medskip

            \begin{lstlisting}[style=mypython, firstnumber=84, caption={[XMagix method startSystem()]XMagix method startSystem().}, label={lst:xmagix startSystem}]
    def startSystem(self):
        """Starts the system previously defined via an .ini file."""

        if self.inifile and self.logpath:
            self.status = self._lib.xiaStartSystem()
            self.CHECK_ERROR("Starting system...")
        else:
            console.log("Set <logpath> and specify <inifile> first.")
            \end{lstlisting}

        \subsection{setAcquisitionValues()}\label{sec:setAcquisitionValues}
            The method \texttt{setAcquisitionValues()} has two positional arguments: the name of a value to set and the desired value itself.
            The name will be checked against a list of allowed names specified in Appendix A of \textit{Handels} programmer guide~\cite{Manual.HandelProgrammersGuideMicroDXP.Xiang}.\par\medskip

            \begin{lstlisting}[style=mypython, firstnumber=117, caption={[XMagix method setAcquisitionValues()]XMagix method setAcquisitionValues().}, label={lst:xmagix setAcquisitionValues}]
    def setAcquisitionValues(self, name, value):
        """
        Translates a high-level acquisition value into the appropriate DSP parameter(s)
        in the hardware. Product-specific Handel manuals list the acquisition values for
        each product.
        """

        if name not in acquisition_values:
            console.log(f"[dark_orange] :warning: Parameter \"{name}\" unknown.")
        else:
            cname = self.stringToBytes(name)
            cvalue = c_double(value)

            self.status = self._lib.xiaSetAcquisitionValues(self.cdetChan, cname, byref(cvalue))
            self.CHECK_ERROR(f"Setting '{name}' to {value}...")
            \end{lstlisting}
        
        \subsection{getAcquisitionValues()}\label{sec:getAcquisitionValues}
            To retrieve a particular~--~or all~--~currently set acquisition value \texttt{getAcquisitionValues(<name>)} can be used.
            The method returns a dictionary where the key-value pair reflects the specified~--~or all~--~name and value.\par\medskip

            \begin{lstlisting}[style=mypython, firstnumber=133, caption={[XMagix method getAcquisitionValues()]XMagix method getAcquisitionValues().}, label={lst:xmagix getAcquisitionValues}]
    def getAcquisitionValues(self, name) -> dict:
        """Retrieves the current setting of an acquisition value. This routine returns the same value as xiaSetAcquisitionValues() in the value parameters."""
        cvalue = c_double(0)

        self.acquisitionParams = []
        self.acquisitionValues = []
        if name == "all":
            for key in acquisition_values:
                self.status = self._lib.xiaGetAcquisitionValues(self.cdetChan, self.stringToBytes(key), byref(cvalue))
                self.acquisitionParams.append(key)
                self.acquisitionValues.append(cvalue.value)
            self.acquisitionValuesDict = dict(zip(self.acquisitionParams, self.acquisitionValues))
        else:
            if name in acquisition_values:
                console.log(f"{name}: {self.acquisitionValuesDict[name]}")
                return self.acquisitionValuesDict[name]
            else:
                console.log(f"[dark_orange] :warning: Parameter <name> unknown.")
                pass
                
        return self.acquisitionValuesDict
            \end{lstlisting}
        
        \subsection{startRun()}\label{sec:startRun}
            The acquisition value \texttt{"preset\_type"} lets the user choose between five modes of data acquisition runs:
            \begin{itemize}
                \item \texttt{"XIA\_PRESET\_NONE"}~--~starts a run until stopped by the user.
                \item \texttt{"XIA\_PRESET\_FIXED\_REAL"}~--~stops after \texttt{"preset\_value"} seconds.
                \item \texttt{"XIA\_PRESET\_FIXED\_LIVE"}~--~stops after \texttt{"preset\_value"} seconds \(+\) the sum of dead times.
                \item \texttt{"XIA\_PRESET\_FIXED\_EVENTS"}~--~stops after \texttt{"preset\_value"} output events.
                \item \texttt{"XIA\_PRESET\_FIXED\_TRIGGERS"}~--~stops after \texttt{"preset\_value"} trigger events.
            \end{itemize}
            Having a \texttt{"preset\_type"} and corresponding \texttt{"preset\_value"} set, \texttt{startRun()} initiates a data acquisition.\par\medskip

            \begin{lstlisting}[style=mypython, firstnumber=217, caption={[XMagix method startRun()]XMagix method startRun().}, label={lst:xmagix startRun}]
    def startRun(self, clearMca=0):
        self.cclearMca = c_short(clearMca)

        self.status = self._lib.xiaStartRun(self.cdetChan, self.cclearMca)
        self.CHECK_ERROR(f"Run started until stopped by user...")
        self.isRunning = True
            \end{lstlisting}

        \subsection{fixedRealtimeRun()}\label{sec:fixedRealtimeRun}
            To directly start a fixed realtime run, the method \texttt{fixedRealtimeRun()} takes the desired realtime in seconds as a mandatory argument.
            The optional argument \texttt{clearMca}, if set to \texttt{True} (default), clears the internal multi-channel analyzers bins prior starting the run.
            During the data acquisition, alongside the elapsed and total time, basic statistics like output count rate (OCR) and the sum of all output events during the run (EIR) are printed to the console in intervals of \qty{1}{\second}.\par\medskip

            \begin{lstlisting}[style=mypython, firstnumber=224, caption={[XMagix method fixedRealtimeRun()]XMagix method fixedRealtimeRun().}, label={lst:xmagix fixedRealtimeRun}]
    def fixedRealtimeRun(self, realtime, clearMca=True):
        """Start fixed realtime run."""

        if type(realtime) == str:
            realtime = float(realtime)
        clearMca = not clearMca
        self.cclearMca = c_short(clearMca) # 0: DO clear MCA, 1: do NOT clear MCA
        crunActive = c_short(0)
        coutputCountRate = c_double(0)
        ceventsInRun = c_ulong(0)
        cruntime = c_double(0)

        self.status = self.setAcquisitionValues("preset_type", CONSTANTS["XIA_PRESET_FIXED_REAL"])
        self.status = self.setAcquisitionValues("preset_value", realtime)

        self.status = self._lib.xiaStartRun(self.cdetChan, self.cclearMca)
        self.CHECK_ERROR("Starting Run...")

        console.clear()
        with console.status(":satellite: out cps: 0, Events: 0") as status:
            for _ in range(10*int(realtime)):
                self._lib.xiaGetRunData(self.cdetChan, self.stringToBytes("output_count_rate"), byref(coutputCountRate))
                self._lib.xiaGetRunData(self.cdetChan, self.stringToBytes("events_in_run"), byref(ceventsInRun))
                self._lib.xiaGetRunData(self.cdetChan, self.stringToBytes("run_active"), byref(crunActive))
                self._lib.xiaGetRunData(self.cdetChan, self.stringToBytes("runtime"), byref(cruntime))
                status.update(f":satellite: Time: {cruntime.value:.1f}/{realtime:.1f}, OCR: {coutputCountRate.value:.2f}, EIR: {ceventsInRun.value}")
                if crunActive.value == 0:
                    break
                time.sleep(1)
        console.log(f"Done. Run statistics: out cps: {coutputCountRate.value:.2f}, Events: {ceventsInRun.value}")
        self.status = self.setAcquisitionValues("preset_type", CONSTANTS["XIA_PRESET_FIXED_NONE"])
            \end{lstlisting}

        \subsection{stopRun()}\label{sec:stopRun}
            A call to \texttt{stopRun()} stops any active run.\par\medskip

            \begin{lstlisting}[style=mypython, firstnumber=256, caption={XMagix method stopRun()}, label={lst:xmagix stopRun}]
    def stopRun(self, stopmessage="Stopped..."):
        """Stops an active run."""

        crunActive = c_short(0)
        self.status = self._lib.xiaGetRunData(self.cdetChan, self.stringToBytes("run_active"), byref(crunActive))

        if self.crunActive.value != 0:
            self.status = self._lib.xiaStopRun(0)
            self.CHECK_ERROR(f"{stopmessage}")
        else:
            console.log(f"No run started. Nothing to do...")
            \end{lstlisting}

        \subsection{pullMcaData()}\label{sec:pullMcaData}
            After data acquisition, \texttt{pullMcaData()} writes the MCA's content to a pre-defined array of length \texttt{nmca} and type \texttt{c\_ulong} and returns it as a \textit{numpy} array.

            \texttt{nmca} is the length of the MCA i.e.~the number of bins (see~\cref{sec:setAcquisitionValues} and~\cref{sec:getAcquisitionValues}).
            Since each bin can hold a maximum number of \(2^{24} - 1 = 16777215\) events, the arrays \textit{ctype} has to be sufficiently large.\par\medskip

            \begin{lstlisting}[style=mypython, firstnumber=271, caption={[XMagix method pullMcaData()]XMagix method pullMcaData().}, label={lst:xmagix pullMcaData}]
    def pullMcaData(self):
        """Time to read out the MCA"""
        
        nmca = self.getAcquisitionValues(name="number_mca_channels")
        cmca = (c_ulong * int(nmca))()

        self.status = self._lib.xiaGetRunData(self.cdetChan, self.stringToBytes("mca"), byref(cmca))
        self.CHECK_ERROR("Pulling MCA...")

        mca = np.ctypeslib.as_array(cmca)
        return mca
            \end{lstlisting}

    \section{X-Ray Source Interface}
        Both the ADC and the DAC utilize the SPI protocol of which the \textit{Raspberry Pi 4 B} has implemented a total of seven hardware buses with two hardware chip selects each.
        With only two peripheral devices attached to the bus~--~the ADC and the DAC~--~only a single bus is needed.
        Here, the default bus \textit{SPI0} is chosen where the physical pin assignment can be seen in~\cref{fig:schematics of raspberry gpio configuration} and is tabulated in~\cref{tab:gpio assignment} for quick reference.

        To gain access to the SBC's GPIO and activate the hardware SPI peripheral, the SBC needs to be configured accordingly.
        \begin{lstlisting}[style=mybash,numbers=none, caption={[Activating SPI0 and installing \texttt{pigpio}]Activating SPI0 and installing \texttt{pigpio}. Enabling the system service ensures automatic start up after boot.},label={lst:SPI0 and pigpio}]
            # Enable SPI0 using raspi-config in non-interactive mode
            sudo raspi-config nonint do_spi 0

            # Install fast GPIO library and activate/start service
            sudo apt-get update
            sudo apt-get install pigpio python-pigpio python3-pigpio
            sudo systemctl enable pigpiod.service
            sudo systemctl start pigpiod.service
        \end{lstlisting}
        \Cref{lst:SPI0 and pigpio} utilizes any \textit{Raspberry Pi OS's} in-build tool \texttt{raspi-config} in non-interactive mode to quickly activate SPI on bus 0.
        After that, \textit{pigpio}~--~a tool for fast GPIO usage~--~is installed and its system service enable to ensure automatic start up in case the host system was rebooted.

        \begin{table}[h]
            \centering
            \caption[Pin assignment of the SBC's GPIO]{Pin assignment of the SBC's GPIO.}%
            \label{tab:gpio assignment}
            \begin{tabular}{@{}lll@{}}
                \toprule
                Function&           Broadcom Pin Name&  Bus Device\\
                \midrule
                MOSI&	            GPIO10&\\
                MISO&	            GPIO09&\\
                SCLK&	            GPIO11&\\
                CE0&	            GPIO08&             ADC\\
                CE1&	            GPIO07&             DAC\\
                Filament Ready&     GPIO24&\\
                HV/Filament Enable& GPIO25&\\
                \bottomrule
            \end{tabular}
        \end{table}

        \subsection{Tube Python Wrapper}
            The Python class \texttt{Tube} implements automatic initialization of the SPI bus and allows easy reading from and writing to the XRS.
            While doing so it has to adhere to the serial interface description and timing requirements of the two different devices connected to the bus.
            Lines \num{7} to \num{17} of the constructor set the pin modes of GPIO24 and GPIO25 responsible i.e. \texttt{Filament Ready} and \texttt{HV/Filament Enable} pins\footnote{Although the full code can be found in~\cref{lst:Tube full source}, reading and writing specific GPIO pins is considered trivial and will not be further elaborated.}.
            Line \num{19} to \num{24} configure the SPI modes for the DAC and the ADC respectively.
            The three arguments of \texttt{spi\_open} set the channel (the CS pin the device is physically connected to), the Baud (clock speed) and the mode.\par\medskip

            Taken from the DAC's datasheet, it operates at a clock speed of \qty{20}{\mega\hertz} with clock polarity 0 and a clock phase 1.
            Clock polarity defines the idle state of the clock, thus, the clocks logic level during a pulse.
            Clock phase defines when a bit is being sampled.
            \Cref{fig:tlv5618a timing req} is taken from the DAC's datasheet and shows that it requires a clock polarity of 0 and samples a bit on the clocks transition to idle.
            
            To reflect that, the third argument of \texttt{spi\_open} needs to be set to 1~\cite{Manual.PigpioLibrary}.
            \begin{figure}[h]
                \centering
                \includesvg[width=.8\textwidth]{electronics/datasheets/tlv5618_timing_req}
                \caption[TLV5618a timing requirements]{TLV5618a timing requirements~\cite{Manual.DAC.TLV5618A}. A bit is read on the falling edge at the end of a clock pulse which translates to clock polarity 0 and clock phase 1.}
                \label{fig:tlv5618a timing req}
            \end{figure}

            \begin{lstlisting}[style=mypython,firstnumber=5, caption={[\texttt{Tube} class's constructor]\texttt{Tube} class's constructor.},label={lst:Tube constructor}]
    def __init__(self, spi_bus: int = 0):

        self.spi_bus = spi_bus

        self.pi = pigpio.pi()
        self.filrdypin = 24
        self.pi.set_pull_up_down(self.filrdypin, pigpio.PUD_DOWN)
        self.pi.set_mode(self.filrdypin, pigpio.INPUT) # GPIO 24

        self.enpin = 25
        self.pi.set_pull_up_down(self.enpin, pigpio.PUD_DOWN)
        self.pi.set_mode(self.enpin, pigpio.OUTPUT) # GPIO 25
        self.pi.write(self.enpin, 0)

        self.dac = self.pi.spi_open(1, 20000000, 1) # device 0 at 20MHz using mode 1 (clk-polarity 0, clock-phase 1)

        # ADC SPI-Com config: T=1 (LSB first on MOSI) (3-wire mode) nnnn=0001 (write 1 bytes then read) W=1 (3-wire) mm=11 (POL1, PHA1)
        # --> 0x4403
        self.adc = self.pi.spi_open(0, 100000, 0) # device 1 at 100kHz using mode 0 (clk-polarity 0, clock-phase 0)
        self.adc_read = 0x1Bfff # Single ended, ODD, channel 1

        self.setHV(0)
        self.setI(0)
        self.disable()
            \end{lstlisting}

    \section{Motion System}
        \lipsum
    \section{User Interface}
        \lipsum